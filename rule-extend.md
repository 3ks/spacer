# 扩展规则

Spacer 本质上是遍历目录，获取需要处理的文件。对于每一个文件，再遍历每一行的内容。

最核心的地方在于每一行的内容如何处理，而 Spacer 将该功能抽象为了 `Amend` 接口，并由实现了该接口的一系列 `规则` 自己去决定如何处理这一行的内容。

如果你想扩展规则，只需要实现 `amend` 包下的 `Amend` 接口即可：

```go
package amend 

type Amend interface {
	AmendText(source string) (new string, stop bool)
	RuleName() string
}
```

该接口仅包含两个方法：

- `RuleName` 方法表示规则名，Spacer 通过该方法区分并实现规则的灵活的拔插。
- `AmendText` 方法表示对内容的处理，这部分内容是 Spacer 的核心，其具体实现取决于接口的实现者。

# 扩展规则注意事项

- 避免规则名与其它规则名重复。

- 每一行的内容末尾无需添加换行符 `\n`，该字符会由 Spacer 统一添加在行尾。如果你确实是要将一行内容转换为多行内容，请自行根据实际情况决定是否添加换行符及缩进。

- `AmendText` 方法的 `stop` 返回值是一个布尔值，绝大多数境况下，都是返回 `stop`，如果要将其值设为 `true`，则 Spacer 不会再执行任何后续的规则检查，并立即返回本行的内容。这一般仅用于一些特殊情况，例如检查是否需要处理本行的内容。如果要将其设为 `true`，请确保你清楚这意味着什么，并且需要明确的说明该规则可能会返回 `stop==true`。

- Spacer 目前的这种接口设计，向规则提供了很大的权限，这是存在一定风险的。例如，你可以实现一个总是返回空字符的规则，那么后续的规则会变得无效，并且最终写回文件系统的文件的内容也会是空。所以，在扩展规则时，请尽量少的改动内容，每条规则仅涉及一类内容的修改，并做好单元测试。

# 不仅是扩展

你不仅可以扩展自己的规则，还可以将其贡献给 Spacer，以帮助更多的使用者。

你还可以帮助改进 Spacer 现有的规则，不管是存在缺陷的规则还是实现得不够优雅的规则，我们都非常欢迎你参与进来。 
